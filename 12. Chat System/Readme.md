# Глава 12: Проектирование системы чата

## Введение
**Система чата** поддерживает обмен сообщениями в реальном времени между пользователями. Эта глава фокусируется на проектировании приложения для чата, которое включает:
- **Чат один на один**
- **Групповой чат (макс. 100 пользователей)**
- **Индикаторы онлайн-статуса**
- **Поддержка нескольких устройств**
- **Push-уведомления**

Целевая аудитория — **50 миллионов активных пользователей в день (DAU)**. История сообщений сохраняется навсегда.

---

## Шаг 1: Понимание задачи

### Требования
1. **Функции:**
   - Чат один на один и групповой чат (макс. 100 участников).
   - Текстовые сообщения (до 100 000 символов).
   - Онлайн/оффлайн-индикаторы.
   - Поддержка нескольких устройств.
   - Push-уведомления.
2. **Масштаб:** 50 миллионов DAU.
3. **Хранение:** постоянная история чата.

---

## Шаг 2: Высокоуровневый дизайн

### Протоколы коммуникации
1. **Отправка:** HTTP с постоянными соединениями для эффективности.

      <div style="margin-left:2rem">
      <img src="./images/basic-design.png" alt="Basic Design" width="500">
      <div>

2. **Получение:**
   - **Polling:** клиент периодически запрашивает наличие новых сообщений.
   - **Long Polling:** соединение поддерживается до получения сообщений.
   - **WebSocket:** двунаправленное постоянное соединение для чата в реальном времени (используется для отправки и получения).

         <img src="./images/polling.png" alt="Polling" width="400">

   - **Long Polling:**
      - Keeps the connection open until messages arrive.
      - Inefficient for inactive users.

         <img src="./images/long-polling.png" alt="Long Polling" width="400">

   - **WebSocket:**
      - A bi-directional, persistent connection for real-time communication, chosen for both sending and receiving messages.
      - Uses WebSockets (ws) protocol for sending and recieving messages.

         <img src="./images/websocket.png" alt="Websocket"  width="400" >

---

### Компоненты

<div style="margin-left:5rem">
   <img src="./images/high-level-stateless-arch.png" alt="High Level Architecture" height="350">
   <img src="./images/high-level-statefull-arch.png" alt="High Level Architecture" height="350" width="550">
</div>

1. **Cервисы не хранящие состояние (Stateless):**
   - Регистрация, вход, управление профилем.
   - Интеграция с сервисом обнаружения — выбор лучшего сервера чата.
2. **Сервисы с состоянием (Stateful):**
   - Серверы чата поддерживают WebSocket соединения.
   - Доставка и синхронизация сообщений.
3. **Сторонние сервисы:**
   - Push-уведомления.
   - Подробнее — см. главу о системе уведомлений.


---
### Дизайн

Клиент поддерживает WebSocket-соединение с сервером чата.

<div style="margin-left:3rem">
      <img src="./images/high-level-design.png" alt="High Level Design" width="450">
</div>

- Серверы чата обрабатывают отправку и получение сообщений.
- Серверы присутствия управляют онлайн/оффлайн статусом.
- API-серверы обрабатывают всё, включая вход пользователя, регистрацию, изменение и др.
- Серверы уведомлений отправляют push-уведомления.
- Наконец, хранилище типа "ключ-значение" используется для хранения истории чатов. Хранилища ключ-значение применяются по следующим причинам:
   - Они позволяют легко масштабироваться по горизонтали.
   - KV-хранилища обеспечивают очень низкую задержку при доступе к данным.
   - Реляционные базы данных плохо справляются с длинными «хвостами» данных. Когда индексы становятся 
   большими, случайный доступ становится дорогим.
   - KV-хранилища используются в других проверенных надёжных чат-приложениях. Например, как 
   в Facebook Messenger и Discord.


Ниже представлены модели данных для чата один на один и группового чата.
   - Первичный ключ — это message_id, который помогает определить порядок сообщений.
   - Для группового чата составной первичный ключ — это (channel_id, message_id).
      - Идентификаторы могут генерироваться с помощью глобального 64-битного генератора, например, Snowflake.
      - Более эффективный подход — использовать локальный генератор последовательности. Локальный означает, что ID уникальны только в рамках одной группы.
      - Причина, по которой локальные ID работают: достаточно поддерживать порядок сообщений внутри одного канала (один-на-один или группа).
      
      <img src="./images/one-to-one-chat.png" alt="One to one chat design" width="300">   
      <img src="./images/group-chat.png" alt="Group chat design" width="300">   


## Шаг 3: Детальное проектирование

### Обнаружение сервисов (Service Discovery)

<div style="margin-left:3rem">
   <img src="./images/zookeeper.png" alt="Zookeeper" width="400">
</div>

- Основная роль механизма обнаружения сервисов — рекомендовать клиенту наилучший сервер чата на основе 
таких критериев, как географическое расположение и загруженность сервера.
- Используется **Apache Zookeeper** для распределения серверов чата с учётом таких критериев, как география и ёмкость сервера.
- Обеспечивает эффективное распределение нагрузки и минимизирует задержки.


### Потоки сообщений
#### Один на один


1. Пользователь A отправляет сообщение на Сервер Чата 1.
2. Сервер Чата 1 присваивает уникальный идентификатор сообщению и сохраняет его в хранилище ключ-значение.
3. Если Пользователь B онлайн, сообщение пересылается на Сервер Чата 2 через постоянное WebSocket-соединение.
4. Если Пользователь B оффлайн, отправляется push-уведомление.



#### Групповой чат

<div style="margin-left:3rem">
   <img src="./images/group-chat-flow.png" alt="Group Chat Flow" width="400">
</div>

- Сообщения копируются в индивидуальные «входящие» каждого получателя в группе.
- Упрощает синхронизацию, но становится затратным при больших группах.
- Со стороны получателя: получатель может получать сообщения от нескольких пользователей. У каждого получателя 
есть «входящие» (очередь синхронизации сообщений), содержащие сообщения от разных отправителей.

---

#### Синхронизация сообщений

Многие пользователи используют несколько устройств. Нам необходимо синхронизировать сообщения между этими устройствами.
Каждое устройство хранит переменную с именем `cur_max_message_id`, которая отслеживает последний ID сообщения на устройстве.
Сообщения, которые удовлетворяют следующим двум условиям, 
считаются новыми сообщениями:

<div style="margin-left:3rem">
   <img src="./images/message-synchronization.png" alt="Message Synchronization"  width="400">
</div>

- Идентификатор получателя совпадает с идентификатором текущего вошедшего в систему пользователя.
- Идентификатор сообщения в хранилище ключ-значение больше, чем `cur_max_message_id`.

---

### Online Presence
1. **Heartbeat Mechanism:**
   <div style="margin-left:3rem">
      <img src="./images/heartbeat-mechanism.png" alt="Heartbeat Mechanism" width="400">
   </div>
   
   - Клиенты периодически отправляют heartbeat-сообщения на серверы присутствия, чтобы указать, что они находятся онлайн.
   - Если heartbeat не получен в течение установленного порога (например, x = 30), пользователь считается оффлайн.

     

2. **Fanout Model:**

   <div style="margin-left:3rem">
      <img src="./images/fanout-presence.png" alt="Fanout Presence" width="400">
   </div>

   - Обновления статуса присутствия передаются друзьям с использованием модели publish-subscribe, где для каждой пары друзей поддерживается отдельный канал.
   - Когда онлайн-статус Пользователя A изменяется, событие публикуется в три канала: A-B, A-C и A-D.
   - Эти три канала подписаны соответственно Пользователями B, C и D, которые получают обновления статуса онлайн.
   - Данный подход эффективен для небольших групп пользователей.


---

## Дополнительные аспекты
### Масштабирование
- **Горизонтальное:** добавление серверов.
- **Балансировка нагрузки**
- **Кэширование**

### Обработка ошибок
- **Повторы:** при сбоях доставки.
- **Отказ серверов:** переименование через Zookeeper.

### Будущие расширения
1. **Поддержка медиа:** изображения/видео сжатие и облако.
2. **End-to-End шифрование**
3. **Кэш на клиенте**
4. **Скорость загрузки:** геораспределённые кэши.

