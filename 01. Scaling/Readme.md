# Глава 1: Масштабирование от нуля до миллионов пользователей

## Введение
Масштабирование системы для поддержки миллионов пользователей — это сложный, итеративный процесс, требующий доработок и оптимизации. В этой главе описывается, как начать с настройки на одном сервере и поэтапно масштабировать архитектуру, чтобы обрабатывать миллионы пользователей.

---

## Раздел 1: Настройка на одном сервере
Изначально все компоненты (веб-приложение, база данных, кэш) работают на одном сервере.

<div style="margin-left:3rem">
   <img src="./images/single-server.png" width="400" />
</div>

### Последовательность запросов
1. Пользователи обращаются к приложению по доменным именам (например, `api.mysite.com`), которые через DNS разрешаются в IP-адреса.
2. IP-адрес веб-сервера возвращается браузеру или мобильному приложению.
3. HTTP-запросы отправляются на веб-сервер, который возвращает HTML или JSON-ответы.

### Источники трафика
1. **Веб-приложения:** Используют серверные языки (например, Python, Java) для бизнес-логики и клиентские языки (например, JavaScript, HTML) для отображения.
2. **Мобильные приложения:** Обмениваются данными с веб-сервером через HTTP и JSON для легковесного взаимодействия.

---

## Раздел 2: Выделение базы данных
По мере роста числа пользователей база данных перемещается на отдельный сервер, чтобы обеспечить независимое масштабирование веб- и базового уровней.

<div style="margin-left:3rem">
   <img src="./images/database.png" width="400" />
</div>

### Выбор базы данных

1. **Реляционные базы данных (SQL):** Структурированные данные хранятся в таблицах. Примеры: MySQL, PostgreSQL.
2. **Нереляционные базы данных (NoSQL):** Подходят для неструктурированных данных или требований с низкой задержкой. Категории включают:
   - Хранилища ключ-значение
   - Графовые базы данных
   - Колонночные хранилища
   - Документные хранилища

- Нереляционные базы данных могут быть правильным выбором, если:
   - приложению требуется сверхнизкая задержка.
   - данные неструктурированы или отсутствуют реляционные связи.
   - требуется только сериализация и десериализация данных (JSON, XML, YAML и т.д.).
   - необходимо хранить огромное количество данных.

---

## Раздел 3: Вертикальное и горизонтальное масштабирование
### Вертикальное масштабирование
- Добавляет ресурсы (CPU, RAM) к существующим серверам.
- Ограничено аппаратными возможностями и не обеспечивает избыточность.

### Горизонтальное масштабирование
- Добавляет больше серверов в пул, что подходит для систем крупного масштаба.
- Балансировщик нагрузки отвечает за маршрутизацию запросов между серверами.

---

## Раздел 4: Балансировщик нагрузки

<div style="margin-left:3rem">
   <img src="./images/load-balancer.png" width="400" />
</div>

Балансировщик нагрузки распределяет трафик между несколькими серверами. Преимущества:
1. **Избыточность:** Если один сервер выходит из строя, трафик перенаправляется на другие.
   - Например, если сервер 1 недоступен, весь трафик перенаправляется на сервер 2.
2. **Масштабируемость:** Легко добавлять сервера для обработки пиковых нагрузок.
   - При резком росте трафика можно добавить дополнительные сервера для обработки нагрузки.

---

## Раздел 5: Репликация базы данных

<div style="margin-left:3rem">
   <img src="./images/database-replication.png" width="400" />
</div>

### Модель мастер-слейв
- **Мастер-база данных:** Обрабатывает операции записи.
   - Все команды по изменению данных (insert, delete, update) отправляются на мастер.
- **Слэйв-базы данных:** Обрабатывают операции чтения, повышая производительность и надежность.
   - Поскольку в большинстве приложений операций чтения больше, чем записи, количество слэйв-баз обычно больше количества мастер-баз.

### Преимущества
1. Улучшенная производительность за счет параллельного чтения.
2. Высокая доступность и надежность данных за счет избыточности.

### Обработка сбоев
- Если единственная слэйв-база данных недоступна, чтение временно перенаправляется на мастер.
- Если есть несколько слэйв-баз, чтение перенаправляется на другие доступные слэйв-базы, а новый сервер заменяет вышедший из строя.
- Если мастер-база недоступна, один из слэйвов повышается до мастера.
- В продуктивных системах слэйв может быть не полностью синхронизирован, поэтому требуется запуск скриптов восстановления данных (методы multi-master и кольцевая репликация могут помочь).

---

## Раздел 6: Кэширование
Кэш хранит часто запрашиваемые данные в памяти, снижая нагрузку на базу данных. Слой кэша — это временное хранилище, работающее быстрее базы данных.

<div style="margin-left:3rem">
   <img src="./images/cache.png" width="500" />
</div>

### Особенности кэширования
1. **Сценарии использования:** Кэш полезен, когда данные часто читаются, но редко изменяются.
2. **Политики истечения срока:** После истечения срока данные удаляются из кэша. Без политики истечения данные остаются в памяти постоянно.
3. **Консистентность:** Требует синхронизации между базой данных и кэшем. Несогласованность может возникать из-за раздельных транзакций.
4. **Отказоустойчивость:** Один сервер кэша — потенциальная точка отказа; рекомендуется использовать несколько серверов кэша в разных дата-центрах.
5. **Политики вытеснения:** При переполнении кэша необходимо выталкивать элементы. LRU — самая популярная политика вытеснения.

---

## Раздел 7: Сеть доставки контента (CDN)
CDN ускоряет загрузку за счет кэширования статического контента (изображения, CSS, JavaScript) на географически распределенных серверах.

<div style="margin-left:3rem">
   <img src="./images/cdn.png" width="400" />
</div>

### Рабочий процесс
1. Пользователь запрашивает контент у ближайшего сервера CDN.
2. Если контент отсутствует, он загружается с исходного сервера и кэшируется.

### Особенности CDN
1. **Стоимость:** CDN предоставляются сторонними провайдерами, которые берут плату за передачу данных.
2. **Время жизни кэша:** Время жизни кэша не должно быть слишком длинным или слишком коротким.
3. **Резервирование CDN:** При сбое CDN клиент должен уметь обнаружить проблему и обратиться к исходному серверу.
4. **Инвалидация:** При обновлении файлов кэш нужно инвалидировать, чтобы клиенты получали актуальные версии.

---

## Раздел 8: Статeless веб-уровень
Перенос данных сессии в общее хранилище делает веб-сервера stateless. Это позволяет:
1. Упрощенное горизонтальное масштабирование.
2. Авто-масштабирование в зависимости от нагрузки.

<div style="margin-left:3rem">
   <img src="./images/stateless.png" width="400" />
</div>

---

## Раздел 9: Настройка нескольких дата-центров
Развертывание в нескольких дата-центрах повышает доступность и снижает задержку. Стратегии включают:

<div style="margin-left:3rem">
   <img src="./images/data-center.png" width="400" />
</div>

1. **GeoDNS:** Направляет пользователей к ближайшему дата-центру.
2. **Репликация данных:** Синхронизирует данные между центрами для предотвращения несогласованности.

### Основные моменты
- **Перенаправление трафика:** Необходимы инструменты для корректного направления трафика.
- **Синхронизация данных:** Обычно выполняется при помощи репликации между дата-центрами.
- **Тестирование и деплой:** Автоматизированные инструменты необходимы для согласованности сервисов во всех центрах.

---

## Раздел 10: Очередь сообщений
Очередь сообщений — это устойчивый компонент в памяти, поддерживающий асинхронную коммуникацию. Она служит буфером и распределяет запросы.

<div style="margin-left:3rem">
   <img src="./images//message-queue.png" width="500" />
</div>

- Сервисы-источники (producers/publishers) создают сообщения и публикуют их в очередь.
- Сервисы-потребители (consumers/subscribers) подключаются к очереди и выполняют действия по сообщениям.

---

## Раздел 11: Логирование, метрики и автоматизация

<div style="margin-left:3rem">
   <img src="./images/logging.png" width="400" />
</div>

### Важность
1. **Логирование:** Отслеживает ошибки и состояние системы.
2. **Метрики:** Дают представление о производительности и активности пользователей.
3. **Автоматизация:** Упрощает тестирование, деплой и масштабирование.

---

## Раздел 12: Масштабирование базы данных
### Вертикальное масштабирование
- Добавление аппаратных ресурсов ограничено физическими и финансовыми возможностями.
- Недостатки:
   - Высокий риск единой точки отказа.
   - Высокая стоимость.

### Горизонтальное масштабирование (шардинг)

<div style="margin-left:3rem">
   <img src="./images/horizontal-scaling.png" width="400" />
</div>

- Разделение данных на несколько шардов по ключам (например, `user_id`).
   - Шардирование разделяет большую базу на более мелкие части, каждая из которых содержит свое подмножество данных.
   - Шарды используют одинаковую схему, но данные различаются.
- Выбор ключа шардирования критичен: он должен обеспечивать равномерное распределение данных.

#### Проблемы
1. **Перешардирование:** Требуется при:
   - Невозможности хранения всех данных на одном шарде.
   - Неравномерном росте нагрузки на разные шарды.
   - Использование консистентного хеширования помогает решить проблему.
2. **Проблема "celebrity":** Повышенная нагрузка на один шард может перегрузить сервер.
   - Решение: выделение отдельного шарда для "известных" пользователей.
3. **JOIN и денормализация:** JOIN между шардами сложен.
   - Обходной путь: денормализация данных для выполнения запросов в одной таблице.

---

## Заключение
### Основные выводы
1. Делайте веб-уровень stateless.
2. Обеспечивайте избыточность на всех уровнях.
3. Используйте кэш и CDN для оптимизации производительности.
4. Масштабируйте базу данных с помощью шардинга.
5. Развязывайте компоненты для гибкости.

Эта глава дает прочную основу для построения масштабируемых систем, способных обслуживать миллионы пользователей.

